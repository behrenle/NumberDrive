RootExpression
	= Definition
	/ Expression

Expression = _ node:FunctionCall _ { return node }

EncapsulatedExpression = "(" node:Expression ")" {
		return node;
	}

// def
Definition = symbol:Symbol _ "=" _ value:Expression {
		return {type: "def", symbol, value};
	}

// item list
Item = _ "," _ value:Expression { return value; }
ItemList = first:Expression rest:Item* {
	return [first].concat(rest);
}

// call
FunctionCall = symbol:Symbol _ "(" _ parameters:ItemList? _ ")" {
		const items = parameters ? parameters : [];
		if (items.length === 1) {
			return {type: "callOrMul", children: [symbol, items[0]]};
		}
		return {type: "call", items, name: symbol.name};
	}
	/ Vec


// Vec
Vec = "[" _ items:ItemList? _ "]" { return {type: "vec", children: items ? items : []}; }
	/ Add

// add
AddItem = Sub / EncapsulatedExpression
Add = left:AddItem? _ "+" _ right:AddItem {
		return {
			type: "add",
			children: [
				left ? left : {type: "num", value: 0},
				right
			]
		};
	}
    / Sub


// sub
SubItem = Mul / EncapsulatedExpression
Sub = left:SubItem? _ "-" _ right:SubItem {
		return {
			type: "sub",
			children: [
				left ? left : {type: "num", value: 0},
				right
			]
		};
	}
	/ Mul

// mul
MulItem = Div / EncapsulatedExpression
Mul = left:MulItem _ "*"? _ right:MulItem { return {type: "mul", children: [left, right]}; }
    / Div

// div
DivItem = Pow / EncapsulatedExpression
Div = left:DivItem _ "/" _ right:DivItem { return {type: "div", children: [left, right]}; }
    / Pow

// pow
PowItem = Primitive / EncapsulatedExpression
Pow = left:PowItem _ "^" _ right:PowItem { return {type: "pow", children: [left, right]}; }
    / Primitive

// primitives
Primitive = Symbol / Number
Symbol = ([a-z] / [A-Z] / "_")+ { return {type: "sym", name: text()}; }
Number = [0-9]+ ("." [0-9]*)? { return {type: "num", value: parseInt(text(), 10)}; }

// misc
_ "whitespace"
  	= [ \t\n\r]*
