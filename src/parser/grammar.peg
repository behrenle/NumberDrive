RootExpression = _ value:(NumericOrBooleanExpression / Definition / GenericExpression / Primitive) _ !(.+) { return value; }

GenericExpression = FunctionCall / Vec
Primitive = BooleanPrimitive / NumericPrimitive / Vec

// definition
Definition = target:(FunctionSignature / Symbol) _ ":=" _ value:NumericOrBooleanExpression {
		return {type: "def", target, value};
	}


// function signature
SymbolType = "number" / "tensor" / "boolean" / "any" { return text(); }
SymbolTypeAnnotation = ":" _ type:SymbolType { return type; }
TypedOrUntypedSymbol = symbol:Symbol _ type:SymbolTypeAnnotation? {
		return {
			type: type ? type : "any",
			name: symbol.name
		};
	}
TypedOrUntypedSymbolListItem = _ "," _ symbol:TypedOrUntypedSymbol { return symbol; }
TypedOrUntypedSymbolList = first:TypedOrUntypedSymbol rest:TypedOrUntypedSymbolListItem* { return [first].concat(rest); }
FunctionSignature = name:Symbol _ "(" _ parameters:TypedOrUntypedSymbolList? _ ")" {
		return {
			type: "FunctionSignature",
			children: parameters ? parameters : []
		};
	}

// item list
ItemValue = NumericOrBooleanExpression / GenericExpression / Primitive
Item = _ "," _ value:(ItemValue) { return value; }
ItemList = first:ItemValue rest:Item* {
	return [first].concat(rest);
}

// call
FunctionCall = symbol:Symbol _ "(" _ parameters:ItemList? _ ")" {
		const items = parameters ? parameters : [];
		if (items.length === 1) {
			return {type: "callOrMul", children: [symbol, items[0]]};
		}
		return {type: "call", items, name: symbol.name};
	}


// Vec
Vec = "[" _ items:ItemList? _ "]" { return {type: "vec", children: items ? items : []}; }


// numeric or boolean expression
NumericOrBooleanExpression = BooleanExpression / NumericExpression


/* boolean expressions */
BooleanExpression = Or
EncapsulatedBooleanExpression = "(" _ value:(BooleanExpression / BooleanAtomic) _ ")" { return value; }
BooleanAtomic = GenericExpression / BooleanPrimitive

OrItem = GenericExpression / And / EncapsulatedBooleanExpression / BooleanPrimitive
Or  = left:OrItem _ "|" _ right:(Or / OrItem) { return {type: "or", children: [left, right]}; }
	/ And

AndItem = GenericExpression / Not / EncapsulatedBooleanExpression / BooleanPrimitive
And = left:AndItem _ "&" _ right:(And / AndItem) { return {type: "and", children: [left, right]}; }
	/ Not

Not = "!" _ value:(EncapsulatedBooleanExpression / BooleanAtomic) { return {type: "not", value}; }

BooleanPrimitive = Boolean / Symbol
Boolean = value:("true" / "false") { return {type: "bool", value: value === "true"}; }



/* numeric expressions */
NumericExpression = Add
EncapsulatedNumericExpression = "(" value:(NumericExpression / NumericAtomic) ")" {
		return value;
	}

NumericAtomic = GenericExpression / NumericPrimitive

// add
AddItem = GenericExpression / Sub / EncapsulatedNumericExpression / NumericPrimitive
Add = left:AddItem? _ "+" _ right:(Add / AddItem) {
		return {
			type: "add",
			children: [
				left ? left : {type: "num", value: 0},
				right
			]
		};
	}
    / Sub


// sub
SubItem = Mul / EncapsulatedNumericExpression / NumericAtomic
Sub = left:SubItem? _ "-" _ right:(SubItem / SubItem) {
		return {
			type: "sub",
			children: [
				left ? left : {type: "num", value: 0},
				right
			]
		};
	}
	/ Mul

// mul
MulItem = Div / EncapsulatedNumericExpression / NumericAtomic
Mul = left:MulItem _ "*"? _ right:(Mul / MulItem) { return {type: "mul", children: [left, right]}; }
    / Div

// div
DivItem = Pow / EncapsulatedNumericExpression / NumericAtomic
Div = left:DivItem _ "/" _ right:(Div / DivItem) { return {type: "div", children: [left, right]}; }
    / Pow

// pow
PowItem = EncapsulatedNumericExpression / NumericAtomic
Pow = left:PowItem _ "^" _ right:PowItem { return {type: "pow", children: [left, right]}; }


// NumericPrimitives
NumericPrimitive = Symbol / Number
Number = [0-9]+ ("." [0-9]*)? { return {type: "num", value: parseInt(text(), 10)}; }


// misc
Symbol = ([a-z] / [A-Z] / "_")+ { return {type: "sym", name: text()}; }

_ "whitespace"
  	= [ \t\n\r]*
